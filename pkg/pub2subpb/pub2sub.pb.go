// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pub2sub/pub2sub.proto

/*
	Package pub2subpb is a generated protocol buffer package.

	It is generated from these files:
		pub2sub/pub2sub.proto

	It has these top-level messages:
		PublishRequest
		PublishResponse
		DistributeRequest
		DistributeResponse
		PlanRequest
		PlanResponse
		ExecuteRequest
		ExecuteResponse
		ChannelMessage
		InternalPublishRequest
		InternalPublishResponse
		InternalPublishMessage
		InternalAckMessage
		InternalEvictMessage
		UDPUnreliableMessage
		StreamRequest
		StreamOpenedEvent
		StreamMessageEvent
		StreamResponse
		AckRequest
		AckResponse
		LeaseRequest
		LeaseResponse
*/
package pub2subpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type UDPMessageType int32

const (
	UDPMessageType_ACK   UDPMessageType = 0
	UDPMessageType_EVICT UDPMessageType = 1
)

var UDPMessageType_name = map[int32]string{
	0: "ACK",
	1: "EVICT",
}
var UDPMessageType_value = map[string]int32{
	"ACK":   0,
	"EVICT": 1,
}

func (x UDPMessageType) String() string {
	return proto.EnumName(UDPMessageType_name, int32(x))
}
func (UDPMessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{0} }

// *************************************************
// Publisher
// ************************************************
type PublishRequest struct {
	Id       string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts       int64    `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message  []byte   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable bool     `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicIds []string `protobuf:"bytes,5,rep,name=topic_ids,json=topicIds" json:"topic_ids,omitempty"`
}

func (m *PublishRequest) Reset()                    { *m = PublishRequest{} }
func (m *PublishRequest) String() string            { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()               {}
func (*PublishRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{0} }

func (m *PublishRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PublishRequest) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *PublishRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PublishRequest) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *PublishRequest) GetTopicIds() []string {
	if m != nil {
		return m.TopicIds
	}
	return nil
}

type PublishResponse struct {
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{1} }

// *************************************************
// Distributor
// ************************************************
type DistributeRequest struct {
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts         int64  `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message    []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable   bool   `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicId    string `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	RangeWidth int32  `protobuf:"varint,6,opt,name=range_width,json=rangeWidth,proto3" json:"range_width,omitempty"`
}

func (m *DistributeRequest) Reset()                    { *m = DistributeRequest{} }
func (m *DistributeRequest) String() string            { return proto.CompactTextString(m) }
func (*DistributeRequest) ProtoMessage()               {}
func (*DistributeRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{2} }

func (m *DistributeRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DistributeRequest) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *DistributeRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *DistributeRequest) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *DistributeRequest) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

func (m *DistributeRequest) GetRangeWidth() int32 {
	if m != nil {
		return m.RangeWidth
	}
	return 0
}

type DistributeResponse struct {
}

func (m *DistributeResponse) Reset()                    { *m = DistributeResponse{} }
func (m *DistributeResponse) String() string            { return proto.CompactTextString(m) }
func (*DistributeResponse) ProtoMessage()               {}
func (*DistributeResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{3} }

// *************************************************
// Planner
// ************************************************
type PlanRequest struct {
	Id         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts         int64  `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message    []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable   bool   `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicId    string `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	RangeBegin string `protobuf:"bytes,6,opt,name=range_begin,json=rangeBegin,proto3" json:"range_begin,omitempty"`
	RangeEnd   string `protobuf:"bytes,7,opt,name=range_end,json=rangeEnd,proto3" json:"range_end,omitempty"`
	RangeWidth int32  `protobuf:"varint,8,opt,name=range_width,json=rangeWidth,proto3" json:"range_width,omitempty"`
}

func (m *PlanRequest) Reset()                    { *m = PlanRequest{} }
func (m *PlanRequest) String() string            { return proto.CompactTextString(m) }
func (*PlanRequest) ProtoMessage()               {}
func (*PlanRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{4} }

func (m *PlanRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PlanRequest) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *PlanRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PlanRequest) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *PlanRequest) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

func (m *PlanRequest) GetRangeBegin() string {
	if m != nil {
		return m.RangeBegin
	}
	return ""
}

func (m *PlanRequest) GetRangeEnd() string {
	if m != nil {
		return m.RangeEnd
	}
	return ""
}

func (m *PlanRequest) GetRangeWidth() int32 {
	if m != nil {
		return m.RangeWidth
	}
	return 0
}

type PlanResponse struct {
}

func (m *PlanResponse) Reset()                    { *m = PlanResponse{} }
func (m *PlanResponse) String() string            { return proto.CompactTextString(m) }
func (*PlanResponse) ProtoMessage()               {}
func (*PlanResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{5} }

// *************************************************
// Executor
// ************************************************
type ExecuteRequest struct {
	Id         string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts         int64    `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message    []byte   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable   bool     `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicId    string   `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	ServerId   string   `protobuf:"bytes,6,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ChannelIds []string `protobuf:"bytes,7,rep,name=channel_ids,json=channelIds" json:"channel_ids,omitempty"`
}

func (m *ExecuteRequest) Reset()                    { *m = ExecuteRequest{} }
func (m *ExecuteRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteRequest) ProtoMessage()               {}
func (*ExecuteRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{6} }

func (m *ExecuteRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExecuteRequest) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *ExecuteRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ExecuteRequest) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *ExecuteRequest) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

func (m *ExecuteRequest) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *ExecuteRequest) GetChannelIds() []string {
	if m != nil {
		return m.ChannelIds
	}
	return nil
}

type ExecuteResponse struct {
}

func (m *ExecuteResponse) Reset()                    { *m = ExecuteResponse{} }
func (m *ExecuteResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteResponse) ProtoMessage()               {}
func (*ExecuteResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{7} }

// *************************************************
// Queue Internal Message
// ************************************************
type ChannelMessage struct {
	Id      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts      int64  `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	TopicId string `protobuf:"bytes,4,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
}

func (m *ChannelMessage) Reset()                    { *m = ChannelMessage{} }
func (m *ChannelMessage) String() string            { return proto.CompactTextString(m) }
func (*ChannelMessage) ProtoMessage()               {}
func (*ChannelMessage) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{8} }

func (m *ChannelMessage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ChannelMessage) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *ChannelMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ChannelMessage) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

// *************************************************
// Subscriber Internal
// ************************************************
type InternalPublishRequest struct {
	ChannelId []string                `protobuf:"bytes,1,rep,name=channel_id,json=channelId" json:"channel_id,omitempty"`
	Message   *InternalPublishMessage `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *InternalPublishRequest) Reset()                    { *m = InternalPublishRequest{} }
func (m *InternalPublishRequest) String() string            { return proto.CompactTextString(m) }
func (*InternalPublishRequest) ProtoMessage()               {}
func (*InternalPublishRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{9} }

func (m *InternalPublishRequest) GetChannelId() []string {
	if m != nil {
		return m.ChannelId
	}
	return nil
}

func (m *InternalPublishRequest) GetMessage() *InternalPublishMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type InternalPublishResponse struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	Success   bool   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *InternalPublishResponse) Reset()                    { *m = InternalPublishResponse{} }
func (m *InternalPublishResponse) String() string            { return proto.CompactTextString(m) }
func (*InternalPublishResponse) ProtoMessage()               {}
func (*InternalPublishResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{10} }

func (m *InternalPublishResponse) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *InternalPublishResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type InternalPublishMessage struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts       int64  `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message  []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable bool   `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicId  string `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
}

func (m *InternalPublishMessage) Reset()                    { *m = InternalPublishMessage{} }
func (m *InternalPublishMessage) String() string            { return proto.CompactTextString(m) }
func (*InternalPublishMessage) ProtoMessage()               {}
func (*InternalPublishMessage) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{11} }

func (m *InternalPublishMessage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *InternalPublishMessage) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *InternalPublishMessage) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *InternalPublishMessage) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *InternalPublishMessage) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

type InternalAckMessage struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	AckId     int64  `protobuf:"varint,2,opt,name=ack_id,json=ackId,proto3" json:"ack_id,omitempty"`
}

func (m *InternalAckMessage) Reset()                    { *m = InternalAckMessage{} }
func (m *InternalAckMessage) String() string            { return proto.CompactTextString(m) }
func (*InternalAckMessage) ProtoMessage()               {}
func (*InternalAckMessage) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{12} }

func (m *InternalAckMessage) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *InternalAckMessage) GetAckId() int64 {
	if m != nil {
		return m.AckId
	}
	return 0
}

type InternalEvictMessage struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (m *InternalEvictMessage) Reset()                    { *m = InternalEvictMessage{} }
func (m *InternalEvictMessage) String() string            { return proto.CompactTextString(m) }
func (*InternalEvictMessage) ProtoMessage()               {}
func (*InternalEvictMessage) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{13} }

func (m *InternalEvictMessage) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

type UDPUnreliableMessage struct {
	Type      UDPMessageType `protobuf:"varint,1,opt,name=type,proto3,enum=pub2sub.UDPMessageType" json:"type,omitempty"`
	ChannelId string         `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	AckId     int64          `protobuf:"varint,3,opt,name=ack_id,json=ackId,proto3" json:"ack_id,omitempty"`
}

func (m *UDPUnreliableMessage) Reset()                    { *m = UDPUnreliableMessage{} }
func (m *UDPUnreliableMessage) String() string            { return proto.CompactTextString(m) }
func (*UDPUnreliableMessage) ProtoMessage()               {}
func (*UDPUnreliableMessage) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{14} }

func (m *UDPUnreliableMessage) GetType() UDPMessageType {
	if m != nil {
		return m.Type
	}
	return UDPMessageType_ACK
}

func (m *UDPUnreliableMessage) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *UDPUnreliableMessage) GetAckId() int64 {
	if m != nil {
		return m.AckId
	}
	return 0
}

// *************************************************
// Subscriber
// ************************************************
type StreamRequest struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	// If reliable is false, server will ack messages
	// on behalf of the client if send appears to succeed.
	Reliable bool `protobuf:"varint,2,opt,name=reliable,proto3" json:"reliable,omitempty"`
}

func (m *StreamRequest) Reset()                    { *m = StreamRequest{} }
func (m *StreamRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()               {}
func (*StreamRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{15} }

func (m *StreamRequest) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *StreamRequest) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

type StreamOpenedEvent struct {
	Resumed bool `protobuf:"varint,1,opt,name=resumed,proto3" json:"resumed,omitempty"`
}

func (m *StreamOpenedEvent) Reset()                    { *m = StreamOpenedEvent{} }
func (m *StreamOpenedEvent) String() string            { return proto.CompactTextString(m) }
func (*StreamOpenedEvent) ProtoMessage()               {}
func (*StreamOpenedEvent) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{16} }

func (m *StreamOpenedEvent) GetResumed() bool {
	if m != nil {
		return m.Resumed
	}
	return false
}

type StreamMessageEvent struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Ts       int64  `protobuf:"varint,2,opt,name=ts,proto3" json:"ts,omitempty"`
	Message  []byte `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	Reliable bool   `protobuf:"varint,4,opt,name=reliable,proto3" json:"reliable,omitempty"`
	TopicId  string `protobuf:"bytes,5,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	AckId    int64  `protobuf:"varint,6,opt,name=ack_id,json=ackId,proto3" json:"ack_id,omitempty"`
}

func (m *StreamMessageEvent) Reset()                    { *m = StreamMessageEvent{} }
func (m *StreamMessageEvent) String() string            { return proto.CompactTextString(m) }
func (*StreamMessageEvent) ProtoMessage()               {}
func (*StreamMessageEvent) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{17} }

func (m *StreamMessageEvent) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StreamMessageEvent) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *StreamMessageEvent) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *StreamMessageEvent) GetReliable() bool {
	if m != nil {
		return m.Reliable
	}
	return false
}

func (m *StreamMessageEvent) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

func (m *StreamMessageEvent) GetAckId() int64 {
	if m != nil {
		return m.AckId
	}
	return 0
}

type StreamResponse struct {
	// Types that are valid to be assigned to Event:
	//	*StreamResponse_StreamOpenedEvent
	//	*StreamResponse_StreamMessageEvent
	Event isStreamResponse_Event `protobuf_oneof:"event"`
}

func (m *StreamResponse) Reset()                    { *m = StreamResponse{} }
func (m *StreamResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()               {}
func (*StreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{18} }

type isStreamResponse_Event interface {
	isStreamResponse_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StreamResponse_StreamOpenedEvent struct {
	StreamOpenedEvent *StreamOpenedEvent `protobuf:"bytes,1,opt,name=stream_opened_event,json=streamOpenedEvent,oneof"`
}
type StreamResponse_StreamMessageEvent struct {
	StreamMessageEvent *StreamMessageEvent `protobuf:"bytes,2,opt,name=stream_message_event,json=streamMessageEvent,oneof"`
}

func (*StreamResponse_StreamOpenedEvent) isStreamResponse_Event()  {}
func (*StreamResponse_StreamMessageEvent) isStreamResponse_Event() {}

func (m *StreamResponse) GetEvent() isStreamResponse_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *StreamResponse) GetStreamOpenedEvent() *StreamOpenedEvent {
	if x, ok := m.GetEvent().(*StreamResponse_StreamOpenedEvent); ok {
		return x.StreamOpenedEvent
	}
	return nil
}

func (m *StreamResponse) GetStreamMessageEvent() *StreamMessageEvent {
	if x, ok := m.GetEvent().(*StreamResponse_StreamMessageEvent); ok {
		return x.StreamMessageEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamResponse_OneofMarshaler, _StreamResponse_OneofUnmarshaler, _StreamResponse_OneofSizer, []interface{}{
		(*StreamResponse_StreamOpenedEvent)(nil),
		(*StreamResponse_StreamMessageEvent)(nil),
	}
}

func _StreamResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamResponse)
	// event
	switch x := m.Event.(type) {
	case *StreamResponse_StreamOpenedEvent:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamOpenedEvent); err != nil {
			return err
		}
	case *StreamResponse_StreamMessageEvent:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StreamMessageEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StreamResponse.Event has unexpected type %T", x)
	}
	return nil
}

func _StreamResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamResponse)
	switch tag {
	case 1: // event.stream_opened_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamOpenedEvent)
		err := b.DecodeMessage(msg)
		m.Event = &StreamResponse_StreamOpenedEvent{msg}
		return true, err
	case 2: // event.stream_message_event
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StreamMessageEvent)
		err := b.DecodeMessage(msg)
		m.Event = &StreamResponse_StreamMessageEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StreamResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamResponse)
	// event
	switch x := m.Event.(type) {
	case *StreamResponse_StreamOpenedEvent:
		s := proto.Size(x.StreamOpenedEvent)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamResponse_StreamMessageEvent:
		s := proto.Size(x.StreamMessageEvent)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type AckRequest struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	AckId     int64  `protobuf:"varint,2,opt,name=ack_id,json=ackId,proto3" json:"ack_id,omitempty"`
}

func (m *AckRequest) Reset()                    { *m = AckRequest{} }
func (m *AckRequest) String() string            { return proto.CompactTextString(m) }
func (*AckRequest) ProtoMessage()               {}
func (*AckRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{19} }

func (m *AckRequest) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *AckRequest) GetAckId() int64 {
	if m != nil {
		return m.AckId
	}
	return 0
}

type AckResponse struct {
}

func (m *AckResponse) Reset()                    { *m = AckResponse{} }
func (m *AckResponse) String() string            { return proto.CompactTextString(m) }
func (*AckResponse) ProtoMessage()               {}
func (*AckResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{20} }

type LeaseRequest struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	TopicId   string `protobuf:"bytes,2,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	// Seconds
	ExpireIn int64 `protobuf:"varint,3,opt,name=expire_in,json=expireIn,proto3" json:"expire_in,omitempty"`
}

func (m *LeaseRequest) Reset()                    { *m = LeaseRequest{} }
func (m *LeaseRequest) String() string            { return proto.CompactTextString(m) }
func (*LeaseRequest) ProtoMessage()               {}
func (*LeaseRequest) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{21} }

func (m *LeaseRequest) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *LeaseRequest) GetTopicId() string {
	if m != nil {
		return m.TopicId
	}
	return ""
}

func (m *LeaseRequest) GetExpireIn() int64 {
	if m != nil {
		return m.ExpireIn
	}
	return 0
}

type LeaseResponse struct {
	// Seconds acquired for.
	Ttl int64 `protobuf:"varint,1,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *LeaseResponse) Reset()                    { *m = LeaseResponse{} }
func (m *LeaseResponse) String() string            { return proto.CompactTextString(m) }
func (*LeaseResponse) ProtoMessage()               {}
func (*LeaseResponse) Descriptor() ([]byte, []int) { return fileDescriptorPub2Sub, []int{22} }

func (m *LeaseResponse) GetTtl() int64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func init() {
	proto.RegisterType((*PublishRequest)(nil), "pub2sub.PublishRequest")
	proto.RegisterType((*PublishResponse)(nil), "pub2sub.PublishResponse")
	proto.RegisterType((*DistributeRequest)(nil), "pub2sub.DistributeRequest")
	proto.RegisterType((*DistributeResponse)(nil), "pub2sub.DistributeResponse")
	proto.RegisterType((*PlanRequest)(nil), "pub2sub.PlanRequest")
	proto.RegisterType((*PlanResponse)(nil), "pub2sub.PlanResponse")
	proto.RegisterType((*ExecuteRequest)(nil), "pub2sub.ExecuteRequest")
	proto.RegisterType((*ExecuteResponse)(nil), "pub2sub.ExecuteResponse")
	proto.RegisterType((*ChannelMessage)(nil), "pub2sub.ChannelMessage")
	proto.RegisterType((*InternalPublishRequest)(nil), "pub2sub.InternalPublishRequest")
	proto.RegisterType((*InternalPublishResponse)(nil), "pub2sub.InternalPublishResponse")
	proto.RegisterType((*InternalPublishMessage)(nil), "pub2sub.InternalPublishMessage")
	proto.RegisterType((*InternalAckMessage)(nil), "pub2sub.InternalAckMessage")
	proto.RegisterType((*InternalEvictMessage)(nil), "pub2sub.InternalEvictMessage")
	proto.RegisterType((*UDPUnreliableMessage)(nil), "pub2sub.UDPUnreliableMessage")
	proto.RegisterType((*StreamRequest)(nil), "pub2sub.StreamRequest")
	proto.RegisterType((*StreamOpenedEvent)(nil), "pub2sub.StreamOpenedEvent")
	proto.RegisterType((*StreamMessageEvent)(nil), "pub2sub.StreamMessageEvent")
	proto.RegisterType((*StreamResponse)(nil), "pub2sub.StreamResponse")
	proto.RegisterType((*AckRequest)(nil), "pub2sub.AckRequest")
	proto.RegisterType((*AckResponse)(nil), "pub2sub.AckResponse")
	proto.RegisterType((*LeaseRequest)(nil), "pub2sub.LeaseRequest")
	proto.RegisterType((*LeaseResponse)(nil), "pub2sub.LeaseResponse")
	proto.RegisterEnum("pub2sub.UDPMessageType", UDPMessageType_name, UDPMessageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PublishService service

type PublishServiceClient interface {
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
}

type publishServiceClient struct {
	cc *grpc.ClientConn
}

func NewPublishServiceClient(cc *grpc.ClientConn) PublishServiceClient {
	return &publishServiceClient{cc}
}

func (c *publishServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	out := new(PublishResponse)
	err := grpc.Invoke(ctx, "/pub2sub.PublishService/Publish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PublishService service

type PublishServiceServer interface {
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
}

func RegisterPublishServiceServer(s *grpc.Server, srv PublishServiceServer) {
	s.RegisterService(&_PublishService_serviceDesc, srv)
}

func _PublishService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublishServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.PublishService/Publish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublishServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PublishService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.PublishService",
	HandlerType: (*PublishServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _PublishService_Publish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pub2sub/pub2sub.proto",
}

// Client API for DistributeService service

type DistributeServiceClient interface {
	Distribute(ctx context.Context, in *DistributeRequest, opts ...grpc.CallOption) (*DistributeResponse, error)
}

type distributeServiceClient struct {
	cc *grpc.ClientConn
}

func NewDistributeServiceClient(cc *grpc.ClientConn) DistributeServiceClient {
	return &distributeServiceClient{cc}
}

func (c *distributeServiceClient) Distribute(ctx context.Context, in *DistributeRequest, opts ...grpc.CallOption) (*DistributeResponse, error) {
	out := new(DistributeResponse)
	err := grpc.Invoke(ctx, "/pub2sub.DistributeService/Distribute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DistributeService service

type DistributeServiceServer interface {
	Distribute(context.Context, *DistributeRequest) (*DistributeResponse, error)
}

func RegisterDistributeServiceServer(s *grpc.Server, srv DistributeServiceServer) {
	s.RegisterService(&_DistributeService_serviceDesc, srv)
}

func _DistributeService_Distribute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistributeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributeServiceServer).Distribute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.DistributeService/Distribute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributeServiceServer).Distribute(ctx, req.(*DistributeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DistributeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.DistributeService",
	HandlerType: (*DistributeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Distribute",
			Handler:    _DistributeService_Distribute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pub2sub/pub2sub.proto",
}

// Client API for PlanService service

type PlanServiceClient interface {
	Plan(ctx context.Context, in *PlanRequest, opts ...grpc.CallOption) (*PlanResponse, error)
}

type planServiceClient struct {
	cc *grpc.ClientConn
}

func NewPlanServiceClient(cc *grpc.ClientConn) PlanServiceClient {
	return &planServiceClient{cc}
}

func (c *planServiceClient) Plan(ctx context.Context, in *PlanRequest, opts ...grpc.CallOption) (*PlanResponse, error) {
	out := new(PlanResponse)
	err := grpc.Invoke(ctx, "/pub2sub.PlanService/Plan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PlanService service

type PlanServiceServer interface {
	Plan(context.Context, *PlanRequest) (*PlanResponse, error)
}

func RegisterPlanServiceServer(s *grpc.Server, srv PlanServiceServer) {
	s.RegisterService(&_PlanService_serviceDesc, srv)
}

func _PlanService_Plan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlanServiceServer).Plan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.PlanService/Plan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlanServiceServer).Plan(ctx, req.(*PlanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PlanService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.PlanService",
	HandlerType: (*PlanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Plan",
			Handler:    _PlanService_Plan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pub2sub/pub2sub.proto",
}

// Client API for ExecuteService service

type ExecuteServiceClient interface {
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error)
}

type executeServiceClient struct {
	cc *grpc.ClientConn
}

func NewExecuteServiceClient(cc *grpc.ClientConn) ExecuteServiceClient {
	return &executeServiceClient{cc}
}

func (c *executeServiceClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*ExecuteResponse, error) {
	out := new(ExecuteResponse)
	err := grpc.Invoke(ctx, "/pub2sub.ExecuteService/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ExecuteService service

type ExecuteServiceServer interface {
	Execute(context.Context, *ExecuteRequest) (*ExecuteResponse, error)
}

func RegisterExecuteServiceServer(s *grpc.Server, srv ExecuteServiceServer) {
	s.RegisterService(&_ExecuteService_serviceDesc, srv)
}

func _ExecuteService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExecuteServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.ExecuteService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExecuteServiceServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExecuteService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.ExecuteService",
	HandlerType: (*ExecuteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _ExecuteService_Execute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pub2sub/pub2sub.proto",
}

// Client API for SubscribeInternalService service

type SubscribeInternalServiceClient interface {
	InternalPublish(ctx context.Context, in *InternalPublishRequest, opts ...grpc.CallOption) (SubscribeInternalService_InternalPublishClient, error)
}

type subscribeInternalServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscribeInternalServiceClient(cc *grpc.ClientConn) SubscribeInternalServiceClient {
	return &subscribeInternalServiceClient{cc}
}

func (c *subscribeInternalServiceClient) InternalPublish(ctx context.Context, in *InternalPublishRequest, opts ...grpc.CallOption) (SubscribeInternalService_InternalPublishClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SubscribeInternalService_serviceDesc.Streams[0], c.cc, "/pub2sub.SubscribeInternalService/InternalPublish", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscribeInternalServiceInternalPublishClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SubscribeInternalService_InternalPublishClient interface {
	Recv() (*InternalPublishResponse, error)
	grpc.ClientStream
}

type subscribeInternalServiceInternalPublishClient struct {
	grpc.ClientStream
}

func (x *subscribeInternalServiceInternalPublishClient) Recv() (*InternalPublishResponse, error) {
	m := new(InternalPublishResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SubscribeInternalService service

type SubscribeInternalServiceServer interface {
	InternalPublish(*InternalPublishRequest, SubscribeInternalService_InternalPublishServer) error
}

func RegisterSubscribeInternalServiceServer(s *grpc.Server, srv SubscribeInternalServiceServer) {
	s.RegisterService(&_SubscribeInternalService_serviceDesc, srv)
}

func _SubscribeInternalService_InternalPublish_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InternalPublishRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscribeInternalServiceServer).InternalPublish(m, &subscribeInternalServiceInternalPublishServer{stream})
}

type SubscribeInternalService_InternalPublishServer interface {
	Send(*InternalPublishResponse) error
	grpc.ServerStream
}

type subscribeInternalServiceInternalPublishServer struct {
	grpc.ServerStream
}

func (x *subscribeInternalServiceInternalPublishServer) Send(m *InternalPublishResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SubscribeInternalService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.SubscribeInternalService",
	HandlerType: (*SubscribeInternalServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InternalPublish",
			Handler:       _SubscribeInternalService_InternalPublish_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pub2sub/pub2sub.proto",
}

// Client API for SubscribeService service

type SubscribeServiceClient interface {
	Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (SubscribeService_StreamClient, error)
	Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error)
	Lease(ctx context.Context, in *LeaseRequest, opts ...grpc.CallOption) (*LeaseResponse, error)
}

type subscribeServiceClient struct {
	cc *grpc.ClientConn
}

func NewSubscribeServiceClient(cc *grpc.ClientConn) SubscribeServiceClient {
	return &subscribeServiceClient{cc}
}

func (c *subscribeServiceClient) Stream(ctx context.Context, in *StreamRequest, opts ...grpc.CallOption) (SubscribeService_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SubscribeService_serviceDesc.Streams[0], c.cc, "/pub2sub.SubscribeService/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &subscribeServiceStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SubscribeService_StreamClient interface {
	Recv() (*StreamResponse, error)
	grpc.ClientStream
}

type subscribeServiceStreamClient struct {
	grpc.ClientStream
}

func (x *subscribeServiceStreamClient) Recv() (*StreamResponse, error) {
	m := new(StreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *subscribeServiceClient) Ack(ctx context.Context, in *AckRequest, opts ...grpc.CallOption) (*AckResponse, error) {
	out := new(AckResponse)
	err := grpc.Invoke(ctx, "/pub2sub.SubscribeService/Ack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscribeServiceClient) Lease(ctx context.Context, in *LeaseRequest, opts ...grpc.CallOption) (*LeaseResponse, error) {
	out := new(LeaseResponse)
	err := grpc.Invoke(ctx, "/pub2sub.SubscribeService/Lease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SubscribeService service

type SubscribeServiceServer interface {
	Stream(*StreamRequest, SubscribeService_StreamServer) error
	Ack(context.Context, *AckRequest) (*AckResponse, error)
	Lease(context.Context, *LeaseRequest) (*LeaseResponse, error)
}

func RegisterSubscribeServiceServer(s *grpc.Server, srv SubscribeServiceServer) {
	s.RegisterService(&_SubscribeService_serviceDesc, srv)
}

func _SubscribeService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SubscribeServiceServer).Stream(m, &subscribeServiceStreamServer{stream})
}

type SubscribeService_StreamServer interface {
	Send(*StreamResponse) error
	grpc.ServerStream
}

type subscribeServiceStreamServer struct {
	grpc.ServerStream
}

func (x *subscribeServiceStreamServer) Send(m *StreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SubscribeService_Ack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServiceServer).Ack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.SubscribeService/Ack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServiceServer).Ack(ctx, req.(*AckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscribeService_Lease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscribeServiceServer).Lease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pub2sub.SubscribeService/Lease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscribeServiceServer).Lease(ctx, req.(*LeaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SubscribeService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pub2sub.SubscribeService",
	HandlerType: (*SubscribeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ack",
			Handler:    _SubscribeService_Ack_Handler,
		},
		{
			MethodName: "Lease",
			Handler:    _SubscribeService_Lease_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _SubscribeService_Stream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pub2sub/pub2sub.proto",
}

func (m *PublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicIds) > 0 {
		for _, s := range m.TopicIds {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DistributeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	if m.RangeWidth != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.RangeWidth))
	}
	return i, nil
}

func (m *DistributeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DistributeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PlanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	if len(m.RangeBegin) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.RangeBegin)))
		i += copy(dAtA[i:], m.RangeBegin)
	}
	if len(m.RangeEnd) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.RangeEnd)))
		i += copy(dAtA[i:], m.RangeEnd)
	}
	if m.RangeWidth != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.RangeWidth))
	}
	return i, nil
}

func (m *PlanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExecuteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	if len(m.ServerId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ServerId)))
		i += copy(dAtA[i:], m.ServerId)
	}
	if len(m.ChannelIds) > 0 {
		for _, s := range m.ChannelIds {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ExecuteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChannelMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	return i, nil
}

func (m *InternalPublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPublishRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		for _, s := range m.ChannelId {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Message != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Message.Size()))
		n1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *InternalPublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.Success {
		dAtA[i] = 0x10
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InternalPublishMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalPublishMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	return i, nil
}

func (m *InternalAckMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalAckMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.AckId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.AckId))
	}
	return i, nil
}

func (m *InternalEvictMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InternalEvictMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	return i, nil
}

func (m *UDPUnreliableMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDPUnreliableMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Type))
	}
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.AckId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.AckId))
	}
	return i, nil
}

func (m *StreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.Reliable {
		dAtA[i] = 0x10
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StreamOpenedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamOpenedEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Resumed {
		dAtA[i] = 0x8
		i++
		if m.Resumed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StreamMessageEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamMessageEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Ts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ts))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Reliable {
		dAtA[i] = 0x20
		i++
		if m.Reliable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	if m.AckId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.AckId))
	}
	return i, nil
}

func (m *StreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		nn2, err := m.Event.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *StreamResponse_StreamOpenedEvent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StreamOpenedEvent != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.StreamOpenedEvent.Size()))
		n3, err := m.StreamOpenedEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *StreamResponse_StreamMessageEvent) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StreamMessageEvent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.StreamMessageEvent.Size()))
		n4, err := m.StreamMessageEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *AckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if m.AckId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.AckId))
	}
	return i, nil
}

func (m *AckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *LeaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.ChannelId)))
		i += copy(dAtA[i:], m.ChannelId)
	}
	if len(m.TopicId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(len(m.TopicId)))
		i += copy(dAtA[i:], m.TopicId)
	}
	if m.ExpireIn != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.ExpireIn))
	}
	return i, nil
}

func (m *LeaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaseResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ttl != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPub2Sub(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func encodeVarintPub2Sub(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PublishRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	if len(m.TopicIds) > 0 {
		for _, s := range m.TopicIds {
			l = len(s)
			n += 1 + l + sovPub2Sub(uint64(l))
		}
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DistributeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.RangeWidth != 0 {
		n += 1 + sovPub2Sub(uint64(m.RangeWidth))
	}
	return n
}

func (m *DistributeResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PlanRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	l = len(m.RangeBegin)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	l = len(m.RangeEnd)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.RangeWidth != 0 {
		n += 1 + sovPub2Sub(uint64(m.RangeWidth))
	}
	return n
}

func (m *PlanResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ExecuteRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if len(m.ChannelIds) > 0 {
		for _, s := range m.ChannelIds {
			l = len(s)
			n += 1 + l + sovPub2Sub(uint64(l))
		}
	}
	return n
}

func (m *ExecuteResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ChannelMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}

func (m *InternalPublishRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		for _, s := range m.ChannelId {
			l = len(s)
			n += 1 + l + sovPub2Sub(uint64(l))
		}
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}

func (m *InternalPublishResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Success {
		n += 2
	}
	return n
}

func (m *InternalPublishMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}

func (m *InternalAckMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.AckId != 0 {
		n += 1 + sovPub2Sub(uint64(m.AckId))
	}
	return n
}

func (m *InternalEvictMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}

func (m *UDPUnreliableMessage) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPub2Sub(uint64(m.Type))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.AckId != 0 {
		n += 1 + sovPub2Sub(uint64(m.AckId))
	}
	return n
}

func (m *StreamRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	return n
}

func (m *StreamOpenedEvent) Size() (n int) {
	var l int
	_ = l
	if m.Resumed {
		n += 2
	}
	return n
}

func (m *StreamMessageEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ts))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.Reliable {
		n += 2
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.AckId != 0 {
		n += 1 + sovPub2Sub(uint64(m.AckId))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *StreamResponse_StreamOpenedEvent) Size() (n int) {
	var l int
	_ = l
	if m.StreamOpenedEvent != nil {
		l = m.StreamOpenedEvent.Size()
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}
func (m *StreamResponse_StreamMessageEvent) Size() (n int) {
	var l int
	_ = l
	if m.StreamMessageEvent != nil {
		l = m.StreamMessageEvent.Size()
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	return n
}
func (m *AckRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.AckId != 0 {
		n += 1 + sovPub2Sub(uint64(m.AckId))
	}
	return n
}

func (m *AckResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *LeaseRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	l = len(m.TopicId)
	if l > 0 {
		n += 1 + l + sovPub2Sub(uint64(l))
	}
	if m.ExpireIn != 0 {
		n += 1 + sovPub2Sub(uint64(m.ExpireIn))
	}
	return n
}

func (m *LeaseResponse) Size() (n int) {
	var l int
	_ = l
	if m.Ttl != 0 {
		n += 1 + sovPub2Sub(uint64(m.Ttl))
	}
	return n
}

func sovPub2Sub(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPub2Sub(x uint64) (n int) {
	return sovPub2Sub(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicIds = append(m.TopicIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeWidth", wireType)
			}
			m.RangeWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DistributeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DistributeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DistributeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeBegin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeBegin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeEnd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeWidth", wireType)
			}
			m.RangeWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeWidth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelIds = append(m.ChannelIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = append(m.ChannelId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &InternalPublishMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalPublishMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalPublishMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalPublishMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalAckMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalAckMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalAckMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckId", wireType)
			}
			m.AckId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InternalEvictMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalEvictMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalEvictMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDPUnreliableMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDPUnreliableMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDPUnreliableMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (UDPMessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckId", wireType)
			}
			m.AckId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamOpenedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamOpenedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamOpenedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resumed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Resumed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamMessageEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamMessageEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamMessageEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reliable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reliable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckId", wireType)
			}
			m.AckId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamOpenedEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamOpenedEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StreamResponse_StreamOpenedEvent{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamMessageEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamMessageEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StreamResponse_StreamMessageEvent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AckId", wireType)
			}
			m.AckId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AckId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPub2Sub
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireIn", wireType)
			}
			m.ExpireIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpireIn |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPub2Sub(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPub2Sub
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPub2Sub(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPub2Sub
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPub2Sub
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPub2Sub
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPub2Sub
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPub2Sub(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPub2Sub = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPub2Sub   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pub2sub/pub2sub.proto", fileDescriptorPub2Sub) }

var fileDescriptorPub2Sub = []byte{
	// 957 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4d, 0x6f, 0xe3, 0x44,
	0x18, 0xee, 0x24, 0x4d, 0xec, 0xbc, 0x69, 0xb3, 0xed, 0x6c, 0xda, 0x9a, 0x54, 0x74, 0x83, 0xc5,
	0x21, 0x80, 0x68, 0x57, 0x59, 0x81, 0x84, 0x96, 0x4b, 0xd3, 0x46, 0xda, 0x2c, 0xcb, 0x6e, 0xe5,
	0x6e, 0x17, 0x69, 0x2f, 0x91, 0x3f, 0x46, 0xc9, 0x28, 0xa9, 0x63, 0x3c, 0x76, 0xd9, 0x9e, 0x39,
	0x71, 0xe3, 0x07, 0x70, 0xe5, 0x3f, 0xc0, 0x89, 0x2b, 0x47, 0xfe, 0x00, 0x12, 0x2a, 0x7f, 0x04,
	0x79, 0x3e, 0x6c, 0xc7, 0x26, 0xa2, 0x5a, 0x04, 0x3d, 0x25, 0xf3, 0xcc, 0xf8, 0x79, 0x9f, 0xe7,
	0x9d, 0x77, 0x66, 0x5e, 0xd8, 0x09, 0x62, 0xa7, 0xcf, 0x62, 0xe7, 0x48, 0xfe, 0x1e, 0x06, 0xe1,
	0x22, 0x5a, 0x60, 0x4d, 0x0e, 0xcd, 0x6f, 0x11, 0xb4, 0xce, 0x62, 0x67, 0x4e, 0xd9, 0xd4, 0x22,
	0x5f, 0xc7, 0x84, 0x45, 0xb8, 0x05, 0x15, 0xea, 0x19, 0xa8, 0x8b, 0x7a, 0x0d, 0xab, 0x42, 0xbd,
	0x64, 0x1c, 0x31, 0xa3, 0xd2, 0x45, 0xbd, 0xaa, 0x55, 0x89, 0x18, 0x36, 0x40, 0xbb, 0x24, 0x8c,
	0xd9, 0x13, 0x62, 0x54, 0xbb, 0xa8, 0xb7, 0x61, 0xa9, 0x21, 0xee, 0x80, 0x1e, 0x92, 0x39, 0xb5,
	0x9d, 0x39, 0x31, 0xd6, 0xbb, 0xa8, 0xa7, 0x5b, 0xe9, 0x18, 0xef, 0x43, 0x23, 0x5a, 0x04, 0xd4,
	0x1d, 0x53, 0x8f, 0x19, 0xb5, 0x6e, 0xb5, 0xd7, 0xb0, 0x74, 0x0e, 0x8c, 0x3c, 0x66, 0x6e, 0xc3,
	0xbd, 0x54, 0x04, 0x0b, 0x16, 0x3e, 0x23, 0xe6, 0x8f, 0x08, 0xb6, 0x4f, 0x29, 0x8b, 0x42, 0xea,
	0xc4, 0x11, 0xf9, 0x6f, 0xb5, 0xbd, 0x03, 0xba, 0xd2, 0x66, 0xd4, 0x38, 0xb7, 0x26, 0xa5, 0xe1,
	0x07, 0xd0, 0x0c, 0x6d, 0x7f, 0x42, 0xc6, 0xdf, 0x50, 0x2f, 0x9a, 0x1a, 0xf5, 0x2e, 0xea, 0xd5,
	0x2c, 0xe0, 0xd0, 0x57, 0x09, 0x62, 0xb6, 0x01, 0xe7, 0x65, 0x4a, 0xf5, 0xbf, 0x23, 0x68, 0x9e,
	0xcd, 0x6d, 0xff, 0xee, 0x75, 0x3b, 0x64, 0x42, 0x7d, 0xae, 0xbb, 0x21, 0x75, 0x0f, 0x12, 0x24,
	0xd9, 0x0f, 0xb1, 0x80, 0xf8, 0x9e, 0xa1, 0xf1, 0x69, 0x9d, 0x03, 0x43, 0xbf, 0xe4, 0x5a, 0x2f,
	0xb9, 0x6e, 0xc1, 0x86, 0xb0, 0x27, 0xfd, 0xfe, 0x82, 0xa0, 0x35, 0x7c, 0x43, 0xdc, 0xbb, 0xdc,
	0xaa, 0x7d, 0x68, 0x30, 0x12, 0x5e, 0x91, 0x30, 0x99, 0x13, 0x86, 0x75, 0x01, 0x88, 0x7c, 0xb8,
	0x53, 0xdb, 0xf7, 0xc9, 0x9c, 0x17, 0xa0, 0xc6, 0x0b, 0x10, 0x24, 0x24, 0x4b, 0x30, 0x35, 0x20,
	0x4d, 0x11, 0x68, 0x9d, 0x88, 0x05, 0x5f, 0x4a, 0x65, 0x6f, 0xef, 0x29, 0xaf, 0x7b, 0x7d, 0x49,
	0xb7, 0x19, 0xc2, 0xee, 0xc8, 0x8f, 0x48, 0xe8, 0xdb, 0xf3, 0xc2, 0x49, 0x7c, 0x17, 0x20, 0x13,
	0x6d, 0x20, 0xae, 0xb9, 0x91, 0x6a, 0xc6, 0x9f, 0x65, 0xd1, 0x12, 0x09, 0xcd, 0xfe, 0x83, 0x43,
	0x75, 0xca, 0x0b, 0x84, 0x52, 0x7f, 0x2a, 0xc7, 0xb4, 0x60, 0xaf, 0x14, 0x53, 0xb8, 0x2e, 0x05,
	0x45, 0xcb, 0x41, 0x0d, 0xd0, 0x58, 0xec, 0xba, 0x84, 0x09, 0xdf, 0xba, 0xa5, 0x86, 0xe6, 0x77,
	0xa8, 0x64, 0xe4, 0xdf, 0xe7, 0xed, 0xed, 0x6a, 0xc1, 0x7c, 0x0a, 0x58, 0x49, 0x39, 0x76, 0x67,
	0x4a, 0xc6, 0x3f, 0x58, 0xdb, 0x81, 0xba, 0xed, 0xce, 0x92, 0x29, 0xa1, 0xac, 0x66, 0xbb, 0xb3,
	0x91, 0x67, 0x7e, 0x02, 0x6d, 0xc5, 0x35, 0xbc, 0xa2, 0x6e, 0x74, 0x3b, 0x36, 0xf3, 0x1a, 0xda,
	0x17, 0xa7, 0x67, 0x17, 0xbe, 0x92, 0xab, 0x3e, 0xfb, 0x08, 0xd6, 0xa3, 0xeb, 0x80, 0xf0, 0x0f,
	0x5a, 0xfd, 0xbd, 0x74, 0xcb, 0x2e, 0x4e, 0xcf, 0xe4, 0x92, 0x97, 0xd7, 0x01, 0xb1, 0xf8, 0xa2,
	0x42, 0x8c, 0xca, 0x6a, 0xc5, 0xd5, 0xbc, 0xe2, 0xa7, 0xb0, 0x79, 0x1e, 0x85, 0xc4, 0xbe, 0x5c,
	0x55, 0x48, 0x05, 0x9a, 0x7c, 0x92, 0x2b, 0xcb, 0x49, 0x36, 0x3f, 0x86, 0x6d, 0xc1, 0xf5, 0x22,
	0x20, 0x3e, 0xf1, 0x86, 0x57, 0xc4, 0x8f, 0x92, 0xfd, 0x0a, 0x09, 0x8b, 0x2f, 0x89, 0x20, 0xd3,
	0x2d, 0x35, 0x34, 0x7f, 0x40, 0x80, 0xc5, 0x7a, 0x69, 0x46, 0x7c, 0xf0, 0xbf, 0x5f, 0x06, 0x59,
	0x66, 0xea, 0xf9, 0xcc, 0xfc, 0x84, 0xa0, 0xa5, 0x52, 0x23, 0xeb, 0xfd, 0x19, 0xdc, 0x67, 0x1c,
	0x19, 0x2f, 0xb8, 0xc3, 0x31, 0x49, 0x14, 0x73, 0xad, 0xcd, 0x7e, 0x27, 0xdd, 0x9e, 0x52, 0x12,
	0x9e, 0xac, 0x59, 0xdb, 0xac, 0x94, 0x99, 0x17, 0xd0, 0x96, 0x6c, 0xd2, 0x80, 0xa4, 0x13, 0x07,
	0x74, 0xbf, 0x40, 0x97, 0xcf, 0xd1, 0x93, 0x35, 0x0b, 0xb3, 0x12, 0x3a, 0xd0, 0xa0, 0xc6, 0x19,
	0xcc, 0x01, 0xc0, 0xb1, 0x3b, 0xbb, 0xe5, 0x8e, 0xae, 0x28, 0xe5, 0x4d, 0x68, 0x72, 0x8e, 0xf4,
	0x82, 0xdb, 0x78, 0x46, 0x6c, 0x46, 0x6e, 0x49, 0x9a, 0x4f, 0x77, 0xa5, 0x74, 0xf7, 0x92, 0x37,
	0x01, 0x0d, 0xc9, 0x98, 0xfa, 0xb2, 0x16, 0x75, 0x01, 0x8c, 0x7c, 0xf3, 0x3d, 0xd8, 0x94, 0x61,
	0x64, 0xca, 0xb7, 0xa0, 0x1a, 0x45, 0x73, 0x1e, 0xa0, 0x6a, 0x25, 0x7f, 0x3f, 0x7c, 0x1f, 0x5a,
	0xcb, 0xf5, 0x8f, 0x35, 0xa8, 0x1e, 0x9f, 0x7c, 0xb1, 0xb5, 0x86, 0x1b, 0x50, 0x1b, 0xbe, 0x1a,
	0x9d, 0xbc, 0xdc, 0x42, 0xfd, 0xe7, 0x69, 0xaf, 0x72, 0x4e, 0xc2, 0x2b, 0xea, 0x12, 0xfc, 0x39,
	0x68, 0x12, 0xc1, 0xd9, 0x49, 0x5a, 0xbe, 0x45, 0x3b, 0x46, 0x79, 0x42, 0xe8, 0xe8, 0xbf, 0xce,
	0xb7, 0x18, 0x8a, 0x72, 0x08, 0x90, 0x81, 0x38, 0x2b, 0x80, 0x52, 0x33, 0xd2, 0xd9, 0xff, 0xdb,
	0x39, 0xc9, 0x3d, 0x10, 0x0d, 0x80, 0x62, 0x7d, 0x04, 0xeb, 0xc9, 0x10, 0xb7, 0x33, 0x31, 0x59,
	0x7b, 0xd0, 0xd9, 0x29, 0xa0, 0x92, 0xe3, 0x79, 0xfa, 0xa8, 0xe6, 0xfc, 0x4a, 0x24, 0xe7, 0x77,
	0xf9, 0xe1, 0xcd, 0xf9, 0x2d, 0x3c, 0x68, 0xfd, 0x10, 0x8c, 0xf3, 0xd8, 0x61, 0x6e, 0x48, 0x1d,
	0xa2, 0xae, 0x34, 0xc5, 0xfc, 0x0a, 0xee, 0x15, 0x2e, 0x6f, 0xbc, 0xf2, 0x39, 0x51, 0x91, 0xba,
	0xab, 0x17, 0x88, 0x88, 0x0f, 0x51, 0xff, 0x67, 0x04, 0x5b, 0x69, 0x50, 0x15, 0xec, 0x31, 0xd4,
	0xc5, 0x01, 0xc0, 0xbb, 0x85, 0x13, 0xa1, 0xa8, 0xf7, 0x4a, 0xb8, 0x62, 0xc4, 0x0f, 0xa1, 0x7a,
	0xec, 0xce, 0xf0, 0xfd, 0x74, 0x45, 0x76, 0x2c, 0x3a, 0xed, 0x65, 0x50, 0xd6, 0xdb, 0xa7, 0x50,
	0xe3, 0x05, 0x88, 0xb3, 0x3c, 0xe7, 0xeb, 0xbe, 0xb3, 0x5b, 0x84, 0xc5, 0x77, 0x83, 0xc7, 0xbf,
	0xde, 0x1c, 0xa0, 0xdf, 0x6e, 0x0e, 0xd0, 0x1f, 0x37, 0x07, 0xe8, 0xfb, 0x3f, 0x0f, 0xd6, 0x5e,
	0x7f, 0x30, 0xa1, 0xd1, 0x34, 0x76, 0x0e, 0xdd, 0xc5, 0xe5, 0xd1, 0x34, 0xa0, 0x9e, 0xbb, 0x70,
	0x67, 0x47, 0x69, 0x8b, 0x3d, 0x9b, 0xa8, 0xff, 0x81, 0xe3, 0xd4, 0x79, 0xa7, 0xfd, 0xe8, 0xaf,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x71, 0x5c, 0x19, 0x82, 0x0b, 0x00, 0x00,
}
